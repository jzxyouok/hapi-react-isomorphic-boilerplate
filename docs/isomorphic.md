# 同构

React 提出了 **虚拟DOM** 的概念，虚拟DOM以对象树的形式保存在内存中，与真实的DOM相映射，每一
次，当我们需要修改DOM时，都只是修改虚拟DOM，然后 ReactDOM 中的的 `render()` 方法会将修改
后的虚拟DOM再次重新渲染至DOM树中。

虚拟DOM给页面带来了前所未有的性能提升，但它同时，还给我们带来了另一个福利，那就是 **服务器端渲
染** —— 在服务器端，将前端的组件渲染成为一段HTML代码字符串。

## 服务器端同构渲染

通过React提供的服务端渲染方法，我们可以在服务器上生成DOM结构，让用户尽早看到页面内容，但是一个
能够正常工作的现代页面，并不仅仅只是有了完整的 DOM 结构就可以的，还包括了对各种用户操作的响应、
交互等，那么，这意味着，我们在服务器端渲完页面之后，还得像以前一样，在客户端再执行一段 JS 代码，
以绑定事件监听、处理异步交互等，这在 React 的世界里，意味着，整个页面的组件都需要重新渲染一次，
这是不可接受的。

因此， **同构** 诞生了，它的基本原理其实很简单，就是在服务器端与客房端使用完全一致的 React 组
件，这样，就可以保证，不管是服务器端渲染，还是客户端渲染，两边的DOM结构是完全一致的，这样，当客
户端代码执行之后，首先判断已有DOM结构是否和即将渲染的DOM结构相同，若相同，则不再重新渲染DOM结构，只进行事件绑定等后续操作即可。

在同构应用中，一套代码（不局限于组件），能够同时运行在客户端和服务端，总体的执行流程如下：

1. 浏览器向服务器发起请求 `get /page/name`
2. 服务器接收请求，并交由 React 路由器处理
3. React 路由器 `match` 到路径为 `/page/name` 的路由
4. `ReactDOM.renderToString()` 方法，将该路由渲染成字符串
5. 服务器将该字符串封装至需要返回的 `html` 字符串中
6. 服务器按收到 `html` 字符串，按 `html` 文档解析并启动 React 应用
7. 在浏览器端，React 应用同样 `match` 到 `/page/name` 路由
8. 前端 React 创建虚拟DOM，同时与现有的DOM结构进行匹配
9. 发现双方一致，所以，不再重新渲染
10. 前端将渲染之后的其它事情执行完毕（比如事件绑定、异步交互等）

## 配合 Redux

前面我们仅仅只是完成了服务器端与客户端在组件层面的同构渲染，但是还未涉及到数据流，比如，若
`/page/name` 页面在渲染前，需要加载一个数据，然后需要将这个数据传递给相应的组件并渲染至页面
中，那么，若我们不把这个数据同步的传递给客户端的 React 应用，则客户端将永远都会检测到双方的DOM
是不一致的，这个时候，就需要有一种方式，将服务器端的数据传递给前端。

关于 `Redux`，本项目提供了一份简单版本的 [帮助文档](redux)，但你同样也可以阅读
[官方文档](http://redux.js.org/)，关于数据传递，官方给出的示例就是，我们将服务器的状态数保
存至 `window` 对象中，然后前端应用在执行时，从 `window` 对象里取出该状态树，并将其作为初始
状态数来创建客户端的状态树。

```javascript
window.__INIT_STATE__ = Serialize(initialState);
```

对，我们使用了
[serialize-javascript](https://github.com/yahoo/serialize-javascript) 
序列化 JS 对象。
